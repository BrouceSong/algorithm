# 算法讲解
## 冒泡
* 比较相邻的元素。如果第一个比第二个大，就交换他们两个。
* 对每一对相邻元素做同样的工作，从开始第一对到结尾的最后一对。在这一点，最后的元素应该会是最大的数。
* 针对所有的元素重复以上的步骤，除了最后一个。
* 持续每次对越来越少的元素重复上面的步骤，直到没有任何一对数字需要比较。
* [具体代码](https://github.com/BrouceSong/algorithm/blob/master/bubbling.go)
## 快速排序
* 快速排序算法通过多次比较和交换来实现排序，其排序流程如下：
* 首先设定一个分界值，通过该分界值将数组分成左右两部分。
* 将大于或等于分界值的数据集中到数组右边，小于分界值的数据集中到数组的左边。此时，左边部分中各元素都小于或等于分界值，而右边部分中各元素都大于或等于分界值。
* 然后，左边和右边的数据可以独立排序。对于左侧的数组数据，又可以取一个分界值，将该部分数据分成左右两部分，同样在左边放置较小值，右边放置较大值。右侧的数组数据也可以做类似处理。
* 重复上述过程，可以看出，这是一个递归定义。通过递归将左侧部分排好序后，再递归排好右侧部分的顺序。当左、右两个部分各数据排序完成后，整个数组的排序也就完成了。
* [具体代码](https://github.com/BrouceSong/algorithm/blob/master/quickly.go)
## 二分法
* 首先，从数组的中间元素开始搜索，如果该元素正好是目标元素，则搜索过程结束，否则执行下一步。
* 如果目标元素大于/小于中间元素，则在数组大于/小于中间元素的那一半区域查找，然后重复步骤1的操作。
* 如果某一步数组为空，则表示找不到目标元素。
* [具体代码](https://github.com/BrouceSong/algorithm/blob/master/dichotomy.go)
## 使数组唯一的最小增量
* 给定整数数组 A，每次 move 操作将会选择任意 A[i]，并将其递增 1。
* 返回使 A 中的每个值都是唯一的最少操作次数。
* 示例 1:
* 输入：[1,2,2]
* 输出：1
* 解释：经过一次 move 操作，数组将变为 [1, 2, 3]。
* 示例 2:
* 输入：[3,2,1,2,1,7]
* 输出：6
* 解释：经过 6 次 move 操作，数组将变为 [3, 4, 1, 2, 5, 7]。
* 可以看出 5 次或 5 次以下的 move 操作是不能让数组的每个值唯一的。
* 提示：
* 0 <= A.length <= 40000
* 0 <= A[i] < 40000
* [具体代码](https://github.com/BrouceSong/algorithm/blob/master/minIncrementforunique.go)
## 团队成员
* [songwenwen@outlook.com](https://github.com/BrouceSong)
## 开源协议
本项目基于 [MIT](https://zh.wikipedia.org/wiki/MIT%E8%A8%B1%E5%8F%AF%E8%AD%89)协议，请自由地享受和参与开源。
